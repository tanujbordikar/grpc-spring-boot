package com.dev;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.springframework.stereotype.Service;

import com.google.protobuf.Descriptors;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

@Service
public class BookAuthorClientService {
	
	private final BookAuthorServiceGrpc.BookAuthorServiceBlockingStub synchronousClient;
	private final BookAuthorServiceGrpc.BookAuthorServiceStub asynchronousClient;

    public BookAuthorClientService() {
        ManagedChannel channel = ManagedChannelBuilder
            .forAddress("localhost", 12000)
            .usePlaintext()
            .build();
        this.synchronousClient = BookAuthorServiceGrpc.newBlockingStub(channel);
        this.asynchronousClient = BookAuthorServiceGrpc.newStub(channel);
    }
    
	public Map<Descriptors.FieldDescriptor, Object> getAuthor(int authorId) {
		Author authorRequest = Author.newBuilder().setAuthorId(authorId).build();
		Author authorResponse = synchronousClient.getAuthor(authorRequest);
		return authorResponse.getAllFields();
	}
	
	public List<Map<Descriptors.FieldDescriptor, Object>> getBooksByAuthor(int authorId) throws InterruptedException{
		final Author authorRequest = Author.newBuilder().setAuthorId(authorId).build();
		final CountDownLatch countDownLatch = new CountDownLatch(1);
		final List<Map<Descriptors.FieldDescriptor, Object>> response = new ArrayList<>();
		asynchronousClient.getBooksByAuthor(authorRequest, new StreamObserver<Book>() {
			
			@Override
			public void onNext(Book book) {
				response.add(book.getAllFields());
			}
			
			@Override
			public void onError(Throwable t) {
				countDownLatch.countDown();
			}
			
			@Override
			public void onCompleted() {
				countDownLatch.countDown();
			}
		});
		boolean await = countDownLatch.await(1, TimeUnit.MINUTES);
        return await ? response : Collections.emptyList();
	}
	
	public Map<String, Map<Descriptors.FieldDescriptor, Object>> getExpensiveBook() throws InterruptedException{
		final CountDownLatch countDownLatch = new CountDownLatch(1);
        final Map<String, Map<Descriptors.FieldDescriptor, Object>> response = new HashMap<>();
		StreamObserver<Book> responseObserver = asynchronousClient.getExpensiveBook(new StreamObserver<Book>() {
			
			@Override
			public void onNext(Book book) {
				response.put("Expensive Book", book.getAllFields());
			}
			
			@Override
			public void onError(Throwable t) {
				countDownLatch.countDown();
			}
			
			@Override
			public void onCompleted() {
				countDownLatch.countDown();
			}
		});
		TempDB.getBooksFromTempDb().forEach(responseObserver::onNext);
		responseObserver.onCompleted();
		boolean await = countDownLatch.await(1, TimeUnit.MINUTES);
        return await ? response : Collections.emptyMap();
	}
}
